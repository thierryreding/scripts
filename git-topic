#!/bin/sh

prefix=staging/
remote=staging/

git_branch_exists()
{
	for branch in "$@"; do
		if ! git rev-parse --verify --quiet $1 > /dev/null 2>&1; then
			return 1
		fi
	done
}

init()
{
	if test "x$2" = "x"; then
		echo "usage: git topic $0 BASE"
		return
	fi

	if git_branch_exists ${prefix}base ${prefix}master; then
		echo "already initialized"
		return
	fi

	git branch ${prefix}base $2
	git branch ${prefix}master $2
}

rebase()
{
	dry_run=no
	shift;

	if ! git_branch_exists ${prefix}base ${prefix}master; then
		echo "topic branches not initialized, run git topic init first"
		return
	fi

	while test "$#" -gt 0; do
		case $1 in
			-n | --dry-run)
				dry_run=yes
				shift
				;;

			*)
				new=$1
				old=$2
				break
				;;
		esac
	done

	if test -z "$old"; then
		old=${prefix}base
	fi

	if test -z "$new"; then
		new=${prefix}base
	fi

	if ! git rev-parse --verify --quiet $old > /dev/null 2>&1; then
		echo "ERROR: old base ($old) not found"
		return 1
	fi

	if ! git rev-parse --verify --quiet $new > /dev/null 2>&1; then
		echo "ERROR: new base ($new) not found"
		return 1
	fi

	oldref=$(git rev-parse --symbolic-full-name $old)
	oldhash=$(git rev-parse $oldref)

	newref=$(git rev-parse --symbolic-full-name $new)

	if git show-ref --dereference $new > /dev/null 2>&1; then
		newhash=$(git rev-parse $newref^{commit})
	else
		newhash=$(git rev-parse $newref)
	fi

	if ! git diff --quiet || ! git diff --cached --quiet; then
		dirty=yes
	else
		dirty=no
	fi

	if test "x$dirty" = "xyes"; then
		if test "x$dry_run" = "xyes"; then
			echo "running: git stash"
		else
			git stash
		fi
	fi

	if test "x$newhash" != "x$oldhash"; then
		while read branch; do
			if test "x${branch###}" != "x${branch}"; then
				continue
			fi

			echo "rebasing $branch onto $newref (old: $oldref)"

			if test "x$dry_run" = "xyes"; then
				echo "running: git checkout $branch"
			else
				git checkout $branch
			fi

			if test "x$dry_run" = "xyes"; then
				echo "running: git rebase --onto $newref $oldref"
			else
				if ! git rebase --onto $newref $oldref; then
					$SHELL <&- < /dev/tty
				fi
			fi
		done < .git/topic-branches

		if test "x$dry_run" = "xyes"; then
			echo "running: git branch -D ${prefix}base"
			echo "running: git branch ${prefix}base $newref"
		else
			git branch -D ${prefix}base
			git branch ${prefix}base $newref
		fi
	else
		echo "$oldref and $newref are the same, rebasing skipped"
	fi

	if test "x$dry_run" = "xyes"; then
		if ! git_branch_exists ${prefix}master; then
			echo "running: git branch ${prefix}master ${prefix}base"
		fi

		echo "running: git checkout ${prefix}master"
		echo "running: git branch ${prefix}master-old"
		echo "running: git reset --hard $newref"
	else
		if ! git_branch_exists ${prefix}master; then
			git branch ${prefix}master ${prefix}base
		fi

		git checkout ${prefix}master
		git branch ${prefix}master-old
		git reset --hard $newref
	fi

	while read branch; do
		if test "x${branch###}" != "x${branch}"; then
			continue
		fi

		if test "x$dry_run" = "xyes"; then
			echo "running: git merge --no-ff $branch"
		else
			echo "merging $branch into ${prefix}master"

			if ! git merge --no-ff $branch; then
				$SHELL <&- < /dev/tty
			fi
		fi
	done < .git/topic-branches

	if test "x$dry_run" = "xyes"; then
		echo "running: git checkout --quiet ${prefix}work"
		echo "running: git rebase --onto ${prefix}master ${prefix}master-old"
	else
		if git checkout --quiet ${prefix}work 2> /dev/null; then
			if ! git rebase --onto ${prefix}master ${prefix}master-old; then
				$SHELL <&- < /dev/tty
			fi
		else
			# create an empty work branch
			git checkout -b ${prefix}work ${prefix}master
		fi
	fi

	if test "x$dry_run" = "xyes"; then
		echo "running: git branch -D ${prefix}master-old"
	else
		git branch -D ${prefix}master-old
	fi

	if test "x$dirty" = "xyes"; then
		if test "x$dry_run" = "xyes"; then
			echo "running: git stash pop"
		else
			git stash pop
		fi
	fi

	echo "git-topic: rebase: all done"
}

push()
{
	shift

	while test "$#" -gt 0; do
		case $1 in
			-n | --dry-run)
				args="$args --dry-run"
				shift
				;;

			-f | --force)
				args="$args --force"
				shift
				;;

			-* | --*)
				echo "push: unknown option $1"
				exit 1
				;;

			*)
				repository="$1"
				shift
				break
				;;
		esac
	done

	if test "x$repository" = "x"; then
		echo "usage: git topic push [options] REPOSITORY"
		exit 1
	fi

	branches="${prefix}base:${remote}base"

	while read branch; do
		if test "x${branch###}" != "x${branch}"; then
			continue
		fi

		if test "x${branch##${prefix}}" == "x${branch}"; then
			echo "not a topic branch: $branch"
			continue
		fi

		branch=${branch##${prefix}}

		branches="$branches ${prefix}${branch}:${remote}${branch}"
	done < .git/topic-branches

	branches="$branches ${prefix}master:${remote}master"
	branches="$branches ${prefix}work:${remote}work"

	echo "pushing $branches to $repository"
	git push $args $repository $branches
}

delete()
{
	shift

	while test "$#" -gt 0; do
		case $1 in
			-n | --dry-run)
				args="$args --dry-run"
				shift
				;;

			-* | --*)
				echo "delete: unknown option $1"
				exit 1
				;;

			*)
				repository="$1"
				shift
				break
				;;
		esac
	done

	if test "x$remote" = "x"; then
		echo "usage: git topic delete [options] REMOTE"
		exit 1
	fi

	args="$args --delete"

	branches="${remote}base"

	while read branch; do
		if test "x${branch###}" != "x${branch}"; then
			continue
		fi

		if test "x${branch##${prefix}}" == "x${branch}"; then
			echo "not a topic branch: $branch"
			continue
		fi

		branch=${branch##${prefix}}

		branches="$branches ${remote}${branch}"
	done < .git/topic-branches

	branches="$branches ${remote}master ${remote}work"

	echo "deleting $branches from $repository"
	git push $args $repository $branches
}

usage()
{
	echo "usage: git topic [command]"
}

if ! test -f .git/topic-branches; then
	echo ".git/topic-branches does not exist"
	exit 1
fi

while test $# -gt 0; do
	if test -n "$prev"; then
		eval "$prev=$1"
		shift; prev=
		continue
	fi

	case $1 in
		--prefix)
			prev=prefix
			shift
			;;

		*)
			break
			;;
	esac
done

remote=${prefix##*:}
prefix=${prefix%%:*}

errors=no

while read branch; do
	case $branch in
		${prefix}base | ${prefix}master | ${prefix}work)
			echo "ERROR: branch ${branch} is special and can't be used in .git/topic-branches"
			errors=yes
			;;

		*)
			;;
	esac
done < .git/topic-branches

if test "x$errors" = "xyes"; then
	echo "ERROR: sanity checks failed for .git/topic-branches, aborting..."
	exit 1
fi

case $1 in
	init)
		init "$@"
		;;

	rebase)
		rebase "$@"
		;;

	push)
		push "$@"
		;;

	delete)
		delete "$@"
		;;

	*)
		usage $0
		;;
esac

exit $?
